package com.proyectolombok.app;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import lombok.experimental.FieldDefaults;

import java.time.LocalDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Builder
@ToString(includeFieldNames = false)
public class Persona {

    long id;
    String nombre;
    String apellido;
    String email;
    int edad;
    int telefono;
    LocalDate fechaNacimiento;
}

/*

1. COLOCAMOS ANOTACION @Getter y @Setter (POR DEFECTO LOS HARA PUBLICO)
PARA COLOCARLOS PROTECTEC O PRIVADOS, SE LES MODIFICA EL ACCES LEVEL (value = AccessLevel.PROTECTED)


2. SI COLOCO LA ANOTACION @SETTER ENCIMA DE LA CLASE, APLICARA EL SETTER PARA TODOS LOS ATRIBUTOS DE LA CLASE
PERO SI LO COLOCO LA ANOTACION ARRIBA DE UN ATRIBUTO, EL SETTER IRA SOLO A ESE ATRIBUTO


3. COMUNMENTE SIEMPRE TENEMOS CONSTRUCTORES VACIOS Y CON TODOS LOS ATRIBUTOS, PERO CON LOMBOK PODEMOS AHORRAR ESO CON LAS ANOTACIONES:
@AllArgsConstructor (recibe todos los atributos de la clase)
@NoArgsConstructor (constructor vacio)
TIENEN IGUALMENTE LA PROPIEDAD ACCES LEVEL PARA MODIFICAR EL ACCESO DE LOS CONSTRUCTORES (access = AccessLevel.PRIVATE)


4. Y ESTA LA PROPIEDAD StaticName PARA CAMBIAR EL NOMBRE DEL METODO CONSTRUCTOR QUE CREA EL OBJETO (staticName = "crearPersona")
creando un metodo estatico llamado "crearPersona", entiendo por estatico, aquellos que no necesitan una instancia de la clase para ser llamado


5. PARA TRABAJAR CON LOS ATRIBUTOS DE LA CLASE, Y ABREVIAR ESCRIBIR PRIVATE EN CADA UNO, PODEMOS USAR LA SIGUIENTE ANOTACION CON SU PROPIEDAD ESPECIFICA
@FieldDefaults(level = AccessLevel.PRIVATE)
Y SI SE QUIERE QUE ALGUNOS ATRIBUTOS TENGAN UN MODIFICADOR DE ACCESO DISTINTO, LO ESCRIBIMOS MANUALMENTE EN EL ATRIBUTO, Y LA ANOTACION DE LOMBOK LO IGNORARA
TAMBIEN EXISTE LA PROPIEDAD makeFinal = true, (level = AccessLevel.PRIVATE, makeFinal = true)
PARA QUE LOS ATRIBUTOS SEAN FINAL, ES DECIR, NO SE PUEDAN MODIFICAR (CONSTANTES)
POR TANTO, DE APLICARSE, OBLIGARA A DARLE VALOR DE INMEDIATO A LOS ATRIBUTOS, YA QUE SI O SI DEBEN TENER UN VALOR PARA SER CONSTANTES, Y NO PUEDE APLICARSE EN CONSTRUCTORES VACIOS


6. GENERALMENTE NECESITAMOS IMPLEMENTAR EL METODO toString PARA IMPRIMIR LOS ATRIBUTOS DE LA CLASE, PERO CON LOMBOK PODEMOS AHORRAR ESO CON LA ANOTACION:
@ToString
Y HAY PROPIEDADES PARA MODIFICAR EL TOSTRING
EJEMPLO = IMPRIMIR TODOS LOS ATRIBUTOS MENOS UNO, con la propiedad: (exclude = {"nombre", "edad"})
Y ESTA LA PROPIEDAD includeFieldNames = false, PARA NO IMPRIMIR LOS NOMBRES DE LOS ATRIBUTOS, Y SOLO MOSTRAR EL VALOR DE ELLOS
Y SI SOLO SE QUIERE QUE SE IMPRIMAN UNOS POCOS ATRIBUTOS, SIN EXCLUIOR LOS DEMAS, SE PUEDE USAR LA PROPIEDAD: (of = {"nombre", "edad"}) Y SOLO SE IMPRIMIRAN ESOS ATRIBUTOS


7. EXISTE LA PROPIEDAD callSuper = true, PARA QUE IMPRIMA LOS ATRIBUTOS DE LA CLASE PADRE, SI ES QUE LA CLASE TIENE UNA CLASE PADRE Y ELLA ES LA HIJA QUE HEREDA


8. PARA LOS METODOS EQUALS Y HASHCODE, SE PUEDE USAR LA ANOTACION @EqualsAndHashCode
CON LAS PROPIEDADES exclude = {"nombre", "edad"} PARA EXCLUIR ATRIBUTOS DEL METODO EQUALS Y HASHCODE
Y LA PROPIEDAD of = {"nombre", "edad"} PARA SOLO GENERAR EL METODO CON ESOS ATRIBUTOS EN EL METODO EQUALS Y HASHCODE
Y LA PROPIEDAD doNotUseGetters = true, PARA QUE NO USE LOS GETTERS DE LOS ATRIBUTOS, Y TOMARA LOS VALORES DIRECTO DE LOS ATRIBUTOS Y LOS COMPARA DIRECTAMENTE (POR DEFECTO ES FALSE ESTA PROPIEDAD)


9. EXISTE UNA ANOTACION QUE RESUME LO ANTERIOR DE FORMA COMPLETA EN UNA SOLA LINEA, Y ES LA ANOTACION @Data
PERO ESTA ANOTACION NO INCLUYE LOS CAMPOS, QUE POR DEFECTO ESTAN EN DEFAULT, Y HABRIA QUE
1) INCLUIRLOS MANUALMENTE, O 2) USAR LA ANOTACION @FieldDefaults(level = AccessLevel.PRIVATE) PARA QUE LOS CAMPOS SEAN PRIVADOS
Y OTRA COSA QUE NO INCLUYE ES EL CONSTRUCTOR CON TODOS LOS ATRIBUTOS, YA QUE SOLO INCLUYE UN CONSTRICTOR VACIO
POR TANTO, SE DEBE USAR @AllArgsConstructor PARA INCLUIR EL CONSTRUCTOR CON TODOS LOS ATRIBUTOS,
PERO AL HACERLO BORRA EL CONSTRUCTOR VACIO, POR LO QUE SE DEBE CREAR MANUALMENTE CON @NoArgsConstructor


10. EXISTE LA ANOTACION BUILDER, QUE PERMITE CREAR OBJETOS DE FORMA MAS FACIL, Y NO NECESITA DE UN CONSTRUCTOR CON TODOS LOS ATRIBUTOS,
APLICANDO EL PATRON DE DISEÃ‘O BUILDER, FORMANDO OBJETOS DINAMICAMENTE, ELIGIENDO QUE ATRIBUTOS TENDRA EL OBJETO, Y CUALES NO
ESTA ANOTACION TIENE PROPIEDADES como access = AccessLevel.PRIVATE, PARA MODIFICAR EL ACCESO DEL BUILDER
Y LA PROPIEDAD builderMethodName = "crearPersona", PARA CAMBIAR EL NOMBRE DEL METODO QUE CREA EL OBJETO, que por defecto es .build
Y OTRO PROPIEDAD ES EL builderClassName = "PersonaBuilder", PARA CAMBIAR EL NOMBRE DE LA CLASE BUILDER, QUE POR DEFECTO ES EL NOMBRE DE LA CLASE + "Builder"


11. CUANDO CREAMOS CLASES EN JAVA, NOS TOPAMOS CON LAS CLASES INMUTABLES DTO (SE LES SETEAN ATRIBUTOS Y UNA VEZ SETEADOS NO SE PUEDEN MODIFICAR)
ES DECIR, CLASES SIN SETTERS QUE MODIFIQUEN LOS ATRIBUTOS, Y CON LOMBOK PODEMOS HACER ESO CON LA ANOTACION @Value
QUE GENERARA UN CONSTRUCTOR Y GETTERS, PERO NO SETTERS, Y LOS ATRIBUTOS SERAN FINAL, ES DECIR, NO SE PODRAN MODIFICAR
Y UNA VEZ GENERADO EL OBJETO CON ESOS ATRIBUTOS, EL OBJETO QUEDARA TAL CUAL DE FORMA INMUTABLE, DEFINIENDOSE LOS ATRIBUTOS COMO PRIVADOS
AGREGANDO LOS METODOS ADICIONALES DE EQUALS, HASHCODE, TOSTRING, Y EL CONSTRUCTOR CON TODOS LOS ATRIBUTOS


12. EXISTE LA ANOTACION @RequiredArgsConstructor, QUE HARA QUE CUANDO CREEMOS UN OBJETO,
NOS OBLIGUE A ENVIAR UN PARAMETRO A LOS ATRIBUTOS MARCADOS FINAL
Y TAMBIEN OBLIGA A ENVIAR PARAMETROS A LOS ATRIBUTOS MARCADOS COMO @NonNull (PARA NUNCA ESTAR NULOS, SE COLOCA ARRIBA DEL ATRIBUTO DESEADO)
ESTAS ANOTACIONES SE PUEDEN COMBINAR CON LA ANOTACION @Data


13. TAMBIEN LOMBOK NOS PROVEE FUNCIONALIDADES PARA MANEJAR LOS LOGS DE LA APLICACION, Y SE PUEDEN UTILIZAR EN CUALQUIER PARTE DE LA APP
CON LA ANOTACION @Log UTILIZANDO EL LOG DE JAVA.UTIL.LOGGING, QUE ES LA LIBRERIA QUE VIENE POR DEFECTO E IMPLICITAMENTE EN JAVA
Y ESA ANOTACION YA PERMITE UTILIZAR LOS METODOS DE LOG, COMO log.info("Mensaje de informacion");, el cual imprimira el nivel del log, e indicara la clase y el mensaje
Y SI SE QUIERE UTILIZAR OTRO LOG CON LIBRERIAS Y DEPENDENCIAS EXTERNAS, SE PUEDE USAR LA ANOTACION @CommonsLog, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CustomLog, @JBossLog, @Flogger, @Log, @Log2j, @Log2j2, @Logback, @Logkit, @LogFactory, @LogFactory2, @LogFactory3, @LogFactory4, @LogFactory5, @LogFactory6, @LogFactory7, @LogFactory8, @LogFactory9, @LogFactory10, @LogFactory11, @LogFactory12, @LogFactory13, @LogFactory


14. EXISTE LA ANOTACION cleanUp = true, PARA QUE LOMBOK CIERRE LOS RECURSOS ABIERTOS, COMO LOS InputStream O SCANNERS,
CUANDO YA NO SE NECESITEN
EJEMPLO = InputStream input = new FileInputStream("archivo.txt");
ESTE RECURSO LUEGO DE IMPLEMENTARSE Y USARSE, HAY QUE CERRARLOS E IMPLEMENTAR UNA EXCEPCION O TRY-CATCH-FINALLY
POR ENDE, ARRIBA DE LA LINEA DE CODIGO QUE NECESITA CERRARSE, SE COLOCA LA ANOTACION @Cleanup, Y LOMBOK SE ENCARGARA DE CERRARLO


15. EXISTE LA ANOTACION @SneakyThrows, QUE PERMITE LANZAR EXCEPCIONES SIN NECESIDAD DE DECLARARLAS EN EL METODO,
Y SE PUEDE USAR EN CUALQUIER METODO
EJEMPLO = EL input.close(); DEBERIA ESTAR DENTRO DE UN TRY-CATCH
PERO CON LA ANOTACION @SneakyThrows, NO ES NECESARIO IMPLEMENTARLO, YA QUE LOMBOK SE ENCARGARA DE LANZAR LA EXCEPCION
Y SE COLOCA ARRIBA DEL METODO QUE NECESITA LANZAR LA EXCEPCION, PUEDE SER ARRIBA DEL MISMO public static void main, O ARRIBA DE UN METODO QUE NECESITE LANZAR UNA EXCEPCION
PARA LANZAR UNA EXCEPCION ESPECIFICA, Y NO LA EXCEPCION POR DEFECTO, SE TIENE LA PROPIEDAD (value = {IOException.class, FileNotFoundException.class})
 */